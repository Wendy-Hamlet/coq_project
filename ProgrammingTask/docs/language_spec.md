# 带类型 WhileD 语言规范

本文档定义了带类型 WhileD 语言的完整语法和语义规则。

## 1. 词法规范

### 1.1 关键字

| 关键字 | 说明 |
|--------|------|
| `skip` | 空语句 |
| `if` / `then` / `else` | 条件语句 |
| `while` / `do` | 循环语句 |
| `short` / `int` / `long` / `long long` | 类型关键字 |

### 1.2 运算符

| 运算符 | 说明 |
|--------|------|
| `=` | 赋值 |
| `+` `-` `*` `/` `%` | 算术运算 |
| `==` `!=` `<` `>` `<=` `>=` | 比较运算 |
| `&&` | 逻辑与 |
| `\|\|` | 逻辑或 |
| `!` | 逻辑非 |
| `&` | 取地址 |
| `*`（一元） | 解引用 |
| `-`（一元） | 取负 |

### 1.3 其他符号

| 符号 | 说明 |
|------|------|
| `;` | 语句分隔符 |
| `(` `)` | 括号（分组、类型转换、条件） |
| `{` `}` | 语句块 |
| `#` | 行注释 |

### 1.4 字面量与标识符

- **整数字面量**：`[0-9]+`
- **标识符**：`[a-zA-Z_][a-zA-Z0-9_]*`

---

## 2. 语法规范（BNF 文法）

```ebnf
program    ::= commands

commands   ::= command
            |  commands ';' command

command    ::= 'skip'
            |  IDENT '=' expr                              # 普通赋值
            |  '*' expr '=' expr                           # 解引用赋值
            |  type IDENT ';' command                       # 变量声明
            |  'if' '(' expr ')' 'then' '{' commands '}' 'else' '{' commands '}'
            |  'while' '(' expr ')' 'do' '{' commands '}'

type       ::= basetype
            |  type '*'

basetype   ::= 'short' | 'int' | 'long' | 'long' 'long'

expr       ::= logic_or

logic_or   ::= logic_and
            |  logic_or '||' logic_and

logic_and  ::= comparison
            |  logic_and '&&' comparison

comparison ::= additive
            |  comparison '==' additive
            |  comparison '!=' additive
            |  comparison '<' additive
            |  comparison '>' additive
            |  comparison '<=' additive
            |  comparison '>=' additive

additive   ::= term
            |  additive '+' term
            |  additive '-' term

term       ::= unary
            |  term '*' unary
            |  term '/' unary
            |  term '%' unary

unary      ::= factor
            |  '-' unary                 # 一元负号
            |  '*' unary                 # 解引用
            |  '!' unary                 # 逻辑非
            |  '&' unary                 # 取地址（可用于左值）

factor     ::= INT_LITERAL
            |  IDENT
            |  '(' expr ')'
            |  '(' type ')' unary        # 类型转换
```

### 2.1 运算符优先级（从低到高）

| 优先级 | 运算符 | 结合性 |
|--------|--------|--------|
| 1 | `\|\|` | 左结合 |
| 2 | `&&` | 左结合 |
| 3 | `==` `!=` `<` `>` `<=` `>=` | 左结合 |
| 4 | `+` `-`（二元） | 左结合 |
| 5 | `*`（乘法） `/` `%` | 左结合 |
| 6 | `-`（一元）`*`（解引用）`!` `&` | 右结合 |
| 7 | `(type)` | 右结合 |

---

## 3. 类型系统

### 3.1 基本类型

| 类型 | 等级 | 说明 |
|------|------|------|
| `short` | 1 | 短整型 |
| `int` | 2 | 整型 |
| `long` | 3 | 长整型 |
| `long long` | 4 | 长长整型 |

### 3.2 指针类型

- 任意类型 `T` 可以构造指针类型 `T*`
- 支持多级指针：`int*`、`int**`、`int***` 等

### 3.3 类型等级

类型等级用于隐式转换判断：`short < int < long < long long`

---

## 4. 隐式类型转换规则

### 4.1 整数提升

当不同整数类型进行运算时，**低等级类型自动提升为高等级类型**：

```
short + int    →  int + int    →  int
int + long     →  long + long  →  long
short + long   →  long + long  →  long
```

### 4.2 赋值转换

赋值时，右值自动转换为左值的类型（需类型兼容）：

```whiled
int x;
long y;
y = x;    # int → long（允许：低到高）
x = y;    # long → int（允许：高到低）
```

> **注意**：本编译器仅实现前端分析（词法、语法、语义检查），不包含代码生成和运行时。
> 高到低的转换在运行时可能导致精度损失（如截断高位、符号变化），但由于没有实际执行，
> 编译器只进行类型兼容性检查，不会产生实际的数值溢出。

### 4.3 整数常量类型

- 常量默认类型为 `long long`（可容纳最大范围）
- 赋值时自动转换为目标类型

### 4.4 指针与整数转换

**隐式转换规则**：指针和整数类型**不允许隐式转换**。

**显式转换规则**：通过类型转换可以在指针和整数之间转换：

```whiled
int* ptr;
long long addr;
int* new_ptr;

addr = (long long)ptr;     # 指针 → 整数（显式转换）
new_ptr = (int*)addr;      # 整数 → 指针（显式转换）

# 错误示例（不允许隐式转换）
# addr = ptr;              # 错误：不能隐式将指针赋值给整数
# new_ptr = addr;          # 错误：不能隐式将整数赋值给指针
```

> **设计说明**：C 语言允许指针和整数之间的隐式转换，但这容易导致类型安全问题。
> 本语言要求显式转换，使代码意图更明确，减少错误。

---

## 5. 类型检查规则

### 5.1 算术运算

| 运算 | 要求 |
|------|------|
| `+` `-` | 整数类型，或指针 ± 整数 |
| `*` `/` `%` | **仅限整数类型**（指针不可参与） |

### 5.2 逻辑运算

| 运算 | 要求 | 返回类型 |
|------|------|----------|
| `&&` | 两个操作数均为整数类型 | int |
| `\|\|` | 两个操作数均为整数类型 | int |
| `!` | 操作数必须是整数类型 | int |

> **设计说明**：本语言**不允许指针参与逻辑运算**。
> 
> 虽然 C 语言允许指针用于布尔上下文（空指针为假，非空为真），但这种设计存在以下问题：
> - **语义模糊**：`!ptr` 是"取反"还是"判空"？
> - **容易出错**：`if (!p)` 和 `if (p == NULL)` 容易混淆
> 
> 现代类型安全语言（如 Rust、Go）通常禁止此用法。本语言采用更严格的类型检查，
> 如需判断指针是否为空，应使用显式比较：`ptr == 0` 或 `ptr != 0`。

### 5.3 指针运算

| 操作 | 规则 | 返回类型 |
|------|------|----------|
| 指针 + 整数 | 允许（指针算术） | 原指针类型 |
| 整数 + 指针 | 允许 | 原指针类型 |
| 指针 - 整数 | 允许 | 原指针类型 |
| 指针 - 指针 | 允许（必须同类型） | `long long`（元素个数） |
| 指针 + 指针 | **禁止** | N/A |
| 指针 * / % | **禁止** | N/A |

**指针减法说明**：
- `ptr1 - ptr2` 返回两个指针之间的元素个数（类型为 `long long`，相当于 C 的 `ptrdiff_t`）
- 仅允许相同类型的指针相减
- 结果在两指针指向同一数组的元素时有意义

### 5.4 比较运算

#### 5.4.1 相等性比较（`==`、`!=`）

| 操作数类型 | 规则 |
|------------|------|
| 整数 vs 整数 | 允许（隐式转换到共同类型） |
| 指针 vs 指针 | 允许（必须是相同指针类型） |
| 指针 vs 整数 | **禁止**（需显式转换） |

```whiled
int* p1;
int* p2;
long** p3;

if (p1 == p2) then { skip }   # 正确：同类型指针
if (p1 == p3) then { skip }   # 错误：不同类型指针
if (p1 == 0) then { skip }    # 错误：指针与整数比较需要转换
if (p1 == (int*)0) then { skip }  # 正确：显式转换
```

#### 5.4.2 关系比较（`<`、`>`、`<=`、`>=`）

| 操作数类型 | 规则 |
|------------|------|
| 整数 vs 整数 | 允许（隐式转换到共同类型） |
| 指针 vs 指针 | 允许（必须是相同指针类型） |
| 指针 vs 整数 | **禁止** |

**指针关系比较说明**：
- 仅当两个指针指向同一数组的元素时，关系比较结果才有意义
- 本编译器在语义分析阶段无法检查指针是否指向同一数组，由程序员保证正确性

### 5.5 一元运算

| 运算 | 要求 |
|------|------|
| `-expr` | `expr` 必须是整数类型 |
| `*expr` | `expr` 必须是指针类型 |
| `!expr` | `expr` 必须是整数类型 |
| `&expr` | `expr` 必须是左值（变量或解引用表达式） |

**取地址运算扩展**：
- `&x`：取变量地址
- `&(*ptr)`：取解引用结果的地址（简化为 `ptr` 本身）
- `&(*(*pptr))`：多级指针解引用后取地址

```whiled
int x;
int* p;
int** pp;

p = &x;           # 变量取地址
pp = &p;          # 指针变量取地址
p = &(*pp);       # 对解引用结果取地址（等价于 pp）
```

### 5.6 变量声明

- 所有变量必须**先声明后使用**
- 同一作用域内不允许**重复声明**

### 5.7 赋值语句

| 语句形式 | 要求 |
|----------|------|
| `x = e` | `x` 必须是已声明的变量，`e` 的类型与 `x` 兼容 |
| `*e1 = e2` | `e1` 必须是指针类型，`e2` 的类型与 `*e1` 兼容 |

### 5.8 条件表达式

- `if` 和 `while` 的条件必须是**整数类型**（非零为真）

---

## 6. 作用域规则

### 6.1 全局作用域

程序顶层的声明属于全局作用域，在整个程序中可见。

### 6.2 块作用域

`if` 和 `while` 的分支/循环体有独立作用域：

```whiled
int x;
x = 1;
if (x > 0) then {
    int y;           # y 仅在 then 分支可见
    y = 2
} else {
    int z;           # z 仅在 else 分支可见
    z = 3
}
# 这里 y 和 z 都不可见
```

---

## 7. 错误类型

### 7.1 词法错误

- 非法字符
- 非法数字格式

### 7.2 语法错误

- 缺少分号或关键字
- 括号不匹配
- 表达式语法错误

### 7.3 语义错误

| 错误 | 说明 |
|------|------|
| 未声明变量 | 使用未声明的变量 |
| 重复声明 | 同一作用域内重复声明变量 |
| 类型不兼容 | 不兼容类型之间的运算或赋值 |
| 非法指针运算 | 指针参与非法运算 |
| 解引用非指针 | 对非指针类型使用 `*` |
| 取地址非左值 | 对非左值使用 `&` |
| 逻辑运算类型错误 | 对指针类型使用 `!`、`&&`、`\|\|` |
| 指针整数比较 | 指针与整数直接比较（需显式转换） |
| 不同类型指针比较 | 比较不同类型的指针 |
| 隐式指针整数转换 | 指针与整数隐式转换（需显式转换） |

---

## 8. 代码示例

### 8.1 完整程序示例

```whiled
# 计算阶乘
int n;
int result;

n = 5;
result = 1;

while (n > 0) do {
    result = result * n;
    n = n - 1
};

# 使用指针
int value;
int* ptr;

value = 100;
ptr = &value;
*ptr = 200
```

### 8.2 逻辑运算示例

```whiled
int a;
int b;
int c;

a = 10;
b = 20;

# 逻辑与
c = (a > 5) && (b < 30);

# 逻辑或
c = (a == 0) || (b != 0);

# 逻辑非
c = !c
```

### 8.3 条件语句示例

```whiled
int x;
int max;

x = 10;

if (x > 0) then {
    max = x
} else {
    max = -x
}
```
