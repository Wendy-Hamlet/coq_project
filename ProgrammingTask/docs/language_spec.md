# 带类型 WhileD 语言规范

本文档定义了带类型 WhileD 语言的完整语法和语义规则。

## 1. 词法规范

### 1.1 关键字

| 关键字 | 说明 |
|--------|------|
| `skip` | 空语句 |
| `if` / `then` / `else` | 条件语句 |
| `while` / `do` | 循环语句 |
| `short` / `int` / `long` / `long long` | 类型关键字 |

### 1.2 运算符

| 运算符 | 说明 |
|--------|------|
| `=` | 赋值 |
| `+` `-` `*` `/` `%` | 算术运算 |
| `==` `!=` `<` `>` `<=` `>=` | 比较运算 |
| `&&` | 逻辑与 |
| `\|\|` | 逻辑或 |
| `!` | 逻辑非 |
| `&` | 取地址 |
| `*`（一元） | 解引用 |
| `-`（一元） | 取负 |

### 1.3 其他符号

| 符号 | 说明 |
|------|------|
| `;` | 语句分隔符 |
| `(` `)` | 括号（分组、类型转换、条件） |
| `{` `}` | 语句块 |
| `#` | 行注释 |

### 1.4 字面量与标识符

- **整数字面量**：`[0-9]+`
- **标识符**：`[a-zA-Z_][a-zA-Z0-9_]*`

---

## 2. 语法规范（BNF 文法）

```ebnf
program    ::= commands

commands   ::= command
            |  commands ';' command

command    ::= 'skip'
            |  IDENT '=' expr                              # 普通赋值
            |  '*' expr '=' expr                           # 解引用赋值
            |  type IDENT ';' command                       # 变量声明
            |  'if' '(' expr ')' 'then' '{' commands '}' 'else' '{' commands '}'
            |  'while' '(' expr ')' 'do' '{' commands '}'

type       ::= basetype
            |  type '*'

basetype   ::= 'short' | 'int' | 'long' | 'long' 'long'

expr       ::= logic_or

logic_or   ::= logic_and
            |  logic_or '||' logic_and

logic_and  ::= comparison
            |  logic_and '&&' comparison

comparison ::= additive
            |  comparison '==' additive
            |  comparison '!=' additive
            |  comparison '<' additive
            |  comparison '>' additive
            |  comparison '<=' additive
            |  comparison '>=' additive

additive   ::= term
            |  additive '+' term
            |  additive '-' term

term       ::= unary
            |  term '*' unary
            |  term '/' unary
            |  term '%' unary

unary      ::= factor
            |  '-' unary                 # 一元负号
            |  '*' unary                 # 解引用
            |  '!' unary                 # 逻辑非
            |  '&' IDENT                 # 取地址

factor     ::= INT_LITERAL
            |  IDENT
            |  '(' expr ')'
            |  '(' type ')' unary        # 类型转换
```

### 2.1 运算符优先级（从低到高）

| 优先级 | 运算符 | 结合性 |
|--------|--------|--------|
| 1 | `\|\|` | 左结合 |
| 2 | `&&` | 左结合 |
| 3 | `==` `!=` `<` `>` `<=` `>=` | 左结合 |
| 4 | `+` `-`（二元） | 左结合 |
| 5 | `*`（乘法） `/` `%` | 左结合 |
| 6 | `-`（一元）`*`（解引用）`!` `&` | 右结合 |
| 7 | `(type)` | 右结合 |

---

## 3. 类型系统

### 3.1 基本类型

| 类型 | 等级 | 说明 |
|------|------|------|
| `short` | 1 | 短整型 |
| `int` | 2 | 整型 |
| `long` | 3 | 长整型 |
| `long long` | 4 | 长长整型 |

### 3.2 指针类型

- 任意类型 `T` 可以构造指针类型 `T*`
- 支持多级指针：`int*`、`int**`、`int***` 等

### 3.3 类型等级

类型等级用于隐式转换判断：`short < int < long < long long`

---

## 4. 隐式类型转换规则

### 4.1 整数提升

当不同整数类型进行运算时，**低等级类型自动提升为高等级类型**：

```
short + int    →  int + int    →  int
int + long     →  long + long  →  long
short + long   →  long + long  →  long
```

### 4.2 赋值转换

赋值时，右值自动转换为左值的类型（需类型兼容）：

```whiled
int x;
long y;
y = x;    # int → long（允许：低到高）
x = y;    # long → int（允许：高到低）
```

> **注意**：本编译器仅实现前端分析（词法、语法、语义检查），不包含代码生成和运行时。
> 高到低的转换在运行时可能导致精度损失（如截断高位、符号变化），但由于没有实际执行，
> 编译器只进行类型兼容性检查，不会产生实际的数值溢出。

### 4.3 整数常量类型

- 常量默认类型为 `long long`（可容纳最大范围）
- 赋值时自动转换为目标类型

---

## 5. 类型检查规则

### 5.1 算术运算

| 运算 | 要求 |
|------|------|
| `+` `-` | 整数类型，或指针 ± 整数 |
| `*` `/` `%` | **仅限整数类型**（指针不可参与） |

### 5.2 逻辑运算

| 运算 | 要求 | 返回类型 |
|------|------|----------|
| `&&` | 两个操作数均为整数类型 | int |
| `\|\|` | 两个操作数均为整数类型 | int |
| `!` | 操作数必须是整数类型 | int |

> **设计说明**：本语言**不允许指针参与逻辑运算**。
> 
> 虽然 C 语言允许指针用于布尔上下文（空指针为假，非空为真），但这种设计存在以下问题：
> - **语义模糊**：`!ptr` 是"取反"还是"判空"？
> - **容易出错**：`if (!p)` 和 `if (p == NULL)` 容易混淆
> 
> 现代类型安全语言（如 Rust、Go）通常禁止此用法。本语言采用更严格的类型检查，
> 如需判断指针是否为空，应使用显式比较：`ptr == 0` 或 `ptr != 0`。

### 5.3 指针运算

| 操作 | 规则 |
|------|------|
| 指针 + 整数 | 允许（指针算术） |
| 整数 + 指针 | 允许 |
| 指针 - 整数 | 允许 |
| 指针 - 指针 | 允许（返回整数，表示元素间距） |
| 指针 + 指针 | **禁止** |
| 指针 * / % | **禁止** |

### 5.4 一元运算

| 运算 | 要求 |
|------|------|
| `-expr` | `expr` 必须是整数类型 |
| `*expr` | `expr` 必须是指针类型 |
| `!expr` | `expr` 必须是整数类型 |
| `&var` | `var` 必须是变量（左值） |

### 5.5 变量声明

- 所有变量必须**先声明后使用**
- 同一作用域内不允许**重复声明**

### 5.6 赋值语句

| 语句形式 | 要求 |
|----------|------|
| `x = e` | `x` 必须是已声明的变量，`e` 的类型与 `x` 兼容 |
| `*e1 = e2` | `e1` 必须是指针类型，`e2` 的类型与 `*e1` 兼容 |

### 5.7 条件表达式

- `if` 和 `while` 的条件必须是**整数类型**（非零为真）

---

## 6. 作用域规则

### 6.1 全局作用域

程序顶层的声明属于全局作用域，在整个程序中可见。

### 6.2 块作用域

`if` 和 `while` 的分支/循环体有独立作用域：

```whiled
int x;
x = 1;
if (x > 0) then {
    int y;           # y 仅在 then 分支可见
    y = 2
} else {
    int z;           # z 仅在 else 分支可见
    z = 3
}
# 这里 y 和 z 都不可见
```

---

## 7. 错误类型

### 7.1 词法错误

- 非法字符
- 非法数字格式

### 7.2 语法错误

- 缺少分号或关键字
- 括号不匹配
- 表达式语法错误

### 7.3 语义错误

| 错误 | 说明 |
|------|------|
| 未声明变量 | 使用未声明的变量 |
| 重复声明 | 同一作用域内重复声明变量 |
| 类型不兼容 | 不兼容类型之间的运算或赋值 |
| 非法指针运算 | 指针参与非法运算 |
| 解引用非指针 | 对非指针类型使用 `*` |
| 取地址非左值 | 对非变量使用 `&` |
| 逻辑运算类型错误 | 对指针类型使用 `!`、`&&`、`\|\|` |

---

## 8. 代码示例

### 8.1 完整程序示例

```whiled
# 计算阶乘
int n;
int result;

n = 5;
result = 1;

while (n > 0) do {
    result = result * n;
    n = n - 1
};

# 使用指针
int value;
int* ptr;

value = 100;
ptr = &value;
*ptr = 200
```

### 8.2 逻辑运算示例

```whiled
int a;
int b;
int c;

a = 10;
b = 20;

# 逻辑与
c = (a > 5) && (b < 30);

# 逻辑或
c = (a == 0) || (b != 0);

# 逻辑非
c = !c
```

### 8.3 条件语句示例

```whiled
int x;
int max;

x = 10;

if (x > 0) then {
    max = x
} else {
    max = -x
}
```
